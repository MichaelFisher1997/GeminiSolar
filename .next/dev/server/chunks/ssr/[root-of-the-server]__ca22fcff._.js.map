{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///home/micqdf/ai-tests/gemini-3-pro/src/game/world/constants.ts"],"sourcesContent":["export const CHUNK_SIZE = 16;\nexport const CHUNK_HEIGHT = 32;\nexport const WORLD_SIZE = 4; // Radius of chunks to generate around player\n\nexport enum BlockType {\n  AIR = 0,\n  GRASS = 1,\n  DIRT = 2,\n  STONE = 3,\n  WATER = 4,\n  WOOD = 5,\n  LEAVES = 6\n}\n\nexport const BlockColors: { [key in BlockType]: number } = {\n  [BlockType.AIR]: 0x000000,\n  [BlockType.GRASS]: 0x567d46,\n  [BlockType.DIRT]: 0x795548,\n  [BlockType.STONE]: 0x808080,\n  [BlockType.WATER]: 0x40a4df,\n  [BlockType.WOOD]: 0x5d4037,\n  [BlockType.LEAVES]: 0x2e7d32\n};\n"],"names":[],"mappings":";;;;;;;;;;;;AAAO,MAAM,aAAa;AACnB,MAAM,eAAe;AACrB,MAAM,aAAa,GAAG,6CAA6C;AAEnE,IAAA,AAAK,mCAAA;;;;;;;;WAAA;;AAUL,MAAM,cAA8C;IACzD,GAAe,EAAE;IACjB,GAAiB,EAAE;IACnB,GAAgB,EAAE;IAClB,GAAiB,EAAE;IACnB,GAAiB,EAAE;IACnB,GAAgB,EAAE;IAClB,GAAkB,EAAE;AACtB"}},
    {"offset": {"line": 48, "column": 0}, "map": {"version":3,"sources":["file:///home/micqdf/ai-tests/gemini-3-pro/src/game/world/Chunk.ts"],"sourcesContent":["import * as THREE from 'three';\nimport { CHUNK_SIZE, CHUNK_HEIGHT, BlockType, BlockColors } from './constants';\nimport { World } from './World';\n\nexport class Chunk {\n  chunkX: number;\n  chunkZ: number;\n  data: Uint8Array;\n  mesh: THREE.Mesh | null = null;\n  world: World;\n  isDirty: boolean = true;\n\n  constructor(x: number, z: number, world: World) {\n    this.chunkX = x;\n    this.chunkZ = z;\n    this.world = world;\n    this.data = new Uint8Array(CHUNK_SIZE * CHUNK_HEIGHT * CHUNK_SIZE);\n  }\n\n  getBlock(x: number, y: number, z: number): BlockType {\n    if (x < 0 || x >= CHUNK_SIZE || y < 0 || y >= CHUNK_HEIGHT || z < 0 || z >= CHUNK_SIZE) {\n      return BlockType.AIR;\n    }\n    return this.data[x + z * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE];\n  }\n\n  setBlock(x: number, y: number, z: number, type: BlockType) {\n    if (x >= 0 && x < CHUNK_SIZE && y >= 0 && y < CHUNK_HEIGHT && z >= 0 && z < CHUNK_SIZE) {\n      this.data[x + z * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE] = type;\n      this.isDirty = true;\n    }\n  }\n\n  generate() {\n    for (let x = 0; x < CHUNK_SIZE; x++) {\n      for (let z = 0; z < CHUNK_SIZE; z++) {\n        const wx = this.chunkX * CHUNK_SIZE + x;\n        const wz = this.chunkZ * CHUNK_SIZE + z;\n\n        // Simplex noise for height\n        const scale = 0.03;\n        const noiseVal = this.world.noise2D(wx * scale, wz * scale);\n        \n        // Map -1..1 to height roughly 4..12\n        const h = Math.floor((noiseVal + 1) * 5) + 5;\n\n        for (let y = 0; y < CHUNK_HEIGHT; y++) {\n          let type = BlockType.AIR;\n          if (y < h - 1) {\n              // Caves? Maybe later. For now solid.\n              type = y < h - 4 ? BlockType.STONE : BlockType.DIRT;\n          }\n          else if (y === h - 1) type = BlockType.GRASS;\n          else if (y < 4) type = BlockType.WATER; // Water level at 4\n\n          if (type !== BlockType.AIR) {\n            this.setBlock(x, y, z, type);\n          }\n        }\n      }\n    }\n    this.isDirty = true;\n  }\n\n  updateMesh() {\n    if (!this.isDirty) return;\n\n    const positions: number[] = [];\n    const normals: number[] = [];\n    const colors: number[] = [];\n    const indices: number[] = [];\n    let indexOffset = 0;\n\n    for (let y = 0; y < CHUNK_HEIGHT; y++) {\n      for (let z = 0; z < CHUNK_SIZE; z++) {\n        for (let x = 0; x < CHUNK_SIZE; x++) {\n          const type = this.getBlock(x, y, z);\n          if (type === BlockType.AIR) continue;\n\n          const colorHex = BlockColors[type];\n          const color = new THREE.Color(colorHex);\n\n          // Check 6 neighbors\n          // If neighbor is AIR (or out of bounds and assuming edge is air for simplicity, \n          // or querying world for neighbor chunk), add face.\n          // For simplicity in this demo, we only check within chunk boundaries or assume AIR at edges\n          // unless we implement cross-chunk meshing.\n          // To make it robust, we should ask World for block at (worldX, y, worldZ).\n\n          const wx = this.chunkX * CHUNK_SIZE + x;\n          const wz = this.chunkZ * CHUNK_SIZE + z;\n\n          const checkNeighbor = (nx: number, ny: number, nz: number) => {\n            // Start with local check for speed\n            if (nx >= 0 && nx < CHUNK_SIZE && ny >= 0 && ny < CHUNK_HEIGHT && nz >= 0 && nz < CHUNK_SIZE) {\n               return this.getBlock(nx, ny, nz) === BlockType.AIR; // Transparent/Air\n            }\n            // Global check (slower but accurate for edges)\n            const nType = this.world.getBlock(this.chunkX * CHUNK_SIZE + nx, ny, this.chunkZ * CHUNK_SIZE + nz);\n            return nType === BlockType.AIR;\n          };\n\n          // Top\n          if (checkNeighbor(x, y + 1, z)) {\n            positions.push(x, y + 1, z + 1,  x + 1, y + 1, z + 1,  x + 1, y + 1, z,  x, y + 1, z);\n            normals.push(0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0);\n            colors.push(color.r, color.g, color.b, color.r, color.g, color.b, color.r, color.g, color.b, color.r, color.g, color.b);\n            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset, indexOffset + 2, indexOffset + 3);\n            indexOffset += 4;\n          }\n          // Bottom\n          if (checkNeighbor(x, y - 1, z)) {\n            positions.push(x, y, z,  x + 1, y, z,  x + 1, y, z + 1,  x, y, z + 1);\n            normals.push(0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0);\n            colors.push(color.r, color.g, color.b, color.r, color.g, color.b, color.r, color.g, color.b, color.r, color.g, color.b);\n            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset, indexOffset + 2, indexOffset + 3);\n            indexOffset += 4;\n          }\n          // Front (Z+)\n          if (checkNeighbor(x, y, z + 1)) {\n            positions.push(x, y, z + 1,  x + 1, y, z + 1,  x + 1, y + 1, z + 1,  x, y + 1, z + 1);\n            normals.push(0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1);\n            colors.push(color.r, color.g, color.b, color.r, color.g, color.b, color.r, color.g, color.b, color.r, color.g, color.b);\n            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset, indexOffset + 2, indexOffset + 3);\n            indexOffset += 4;\n          }\n          // Back (Z-)\n          if (checkNeighbor(x, y, z - 1)) {\n            positions.push(x + 1, y, z,  x, y, z,  x, y + 1, z,  x + 1, y + 1, z);\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n            colors.push(color.r, color.g, color.b, color.r, color.g, color.b, color.r, color.g, color.b, color.r, color.g, color.b);\n            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset, indexOffset + 2, indexOffset + 3);\n            indexOffset += 4;\n          }\n          // Right (X+)\n          if (checkNeighbor(x + 1, y, z)) {\n            positions.push(x + 1, y, z + 1,  x + 1, y, z,  x + 1, y + 1, z,  x + 1, y + 1, z + 1);\n            normals.push(1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0);\n            colors.push(color.r, color.g, color.b, color.r, color.g, color.b, color.r, color.g, color.b, color.r, color.g, color.b);\n            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset, indexOffset + 2, indexOffset + 3);\n            indexOffset += 4;\n          }\n          // Left (X-)\n          if (checkNeighbor(x - 1, y, z)) {\n            positions.push(x, y, z,  x, y, z + 1,  x, y + 1, z + 1,  x, y + 1, z);\n            normals.push(-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0);\n            colors.push(color.r, color.g, color.b, color.r, color.g, color.b, color.r, color.g, color.b, color.r, color.g, color.b);\n            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset, indexOffset + 2, indexOffset + 3);\n            indexOffset += 4;\n          }\n        }\n      }\n    }\n\n    const geometry = new THREE.BufferGeometry();\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n    geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\n    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n    geometry.setIndex(indices);\n\n    if (this.mesh) {\n        // Dispose old geometry\n        this.mesh.geometry.dispose();\n        this.mesh.geometry = geometry;\n    } else {\n        const material = new THREE.MeshStandardMaterial({ vertexColors: true });\n        this.mesh = new THREE.Mesh(geometry, material);\n        this.mesh.castShadow = true;\n        this.mesh.receiveShadow = true;\n        this.mesh.position.set(this.chunkX * CHUNK_SIZE, 0, this.chunkZ * CHUNK_SIZE);\n        this.world.scene.add(this.mesh);\n    }\n\n    this.isDirty = false;\n  }\n  \n  dispose() {\n    if (this.mesh) {\n        this.mesh.geometry.dispose();\n        (this.mesh.material as THREE.Material).dispose();\n        this.world.scene.remove(this.mesh);\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 221, "column": 0}, "map": {"version":3,"sources":["file:///home/micqdf/ai-tests/gemini-3-pro/src/game/world/World.ts"],"sourcesContent":["import * as THREE from 'three';\nimport { createNoise2D, NoiseFunction2D } from 'simplex-noise';\nimport { Chunk } from './Chunk';\nimport { BlockType, CHUNK_SIZE, WORLD_SIZE } from './constants';\n\nexport class World {\n  scene: THREE.Scene;\n  chunks: Map<string, Chunk> = new Map();\n  noise2D: NoiseFunction2D;\n\n  constructor(scene: THREE.Scene) {\n    this.scene = scene;\n    this.noise2D = createNoise2D();\n    // Initial generation will happen via update\n  }\n\n  update(playerPosition: THREE.Vector3) {\n    const chunkX = Math.floor(playerPosition.x / CHUNK_SIZE);\n    const chunkZ = Math.floor(playerPosition.z / CHUNK_SIZE);\n\n    // Load chunks around player\n    for (let x = -WORLD_SIZE; x <= WORLD_SIZE; x++) {\n      for (let z = -WORLD_SIZE; z <= WORLD_SIZE; z++) {\n        const cx = chunkX + x;\n        const cz = chunkZ + z;\n        const key = `${cx},${cz}`;\n\n        if (!this.chunks.has(key)) {\n          const chunk = new Chunk(cx, cz, this);\n          chunk.generate();\n          chunk.updateMesh();\n          this.chunks.set(key, chunk);\n        }\n      }\n    }\n    \n    // Simple unload logic could be added here (remove chunks far away)\n  }\n\n  getBlock(x: number, y: number, z: number): BlockType {\n    const cx = Math.floor(x / CHUNK_SIZE);\n    const cz = Math.floor(z / CHUNK_SIZE);\n    const key = `${cx},${cz}`;\n\n    const chunk = this.chunks.get(key);\n    if (!chunk) return BlockType.AIR; // Assume air if chunk not loaded\n\n    const lx = x - cx * CHUNK_SIZE;\n    const lz = z - cz * CHUNK_SIZE;\n    \n    return chunk.getBlock(lx, y, lz);\n  }\n\n  setBlock(x: number, y: number, z: number, type: BlockType) {\n    const cx = Math.floor(x / CHUNK_SIZE);\n    const cz = Math.floor(z / CHUNK_SIZE);\n    const key = `${cx},${cz}`;\n\n    let chunk = this.chunks.get(key);\n    if (!chunk) {\n        // Optional: Create chunk if not exists? For now, ignore setting blocks in void\n        return;\n    }\n\n    const lx = x - cx * CHUNK_SIZE;\n    const lz = z - cz * CHUNK_SIZE;\n    \n    chunk.setBlock(lx, y, lz, type);\n    chunk.updateMesh();\n    \n    // Update neighbors if on edge\n    if (lx === 0) this.updateChunkMesh(cx - 1, cz);\n    if (lx === CHUNK_SIZE - 1) this.updateChunkMesh(cx + 1, cz);\n    if (lz === 0) this.updateChunkMesh(cx, cz - 1);\n    if (lz === CHUNK_SIZE - 1) this.updateChunkMesh(cx, cz + 1);\n  }\n\n  updateChunkMesh(cx: number, cz: number) {\n    const key = `${cx},${cz}`;\n    const chunk = this.chunks.get(key);\n    if (chunk) {\n        chunk.isDirty = true;\n        chunk.updateMesh();\n    }\n  }\n}\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAEO,MAAM;IACX,MAAmB;IACnB,SAA6B,IAAI,MAAM;IACvC,QAAyB;IAEzB,YAAY,KAAkB,CAAE;QAC9B,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,OAAO,GAAG,IAAA,oLAAa;IAC5B,4CAA4C;IAC9C;IAEA,OAAO,cAA6B,EAAE;QACpC,MAAM,SAAS,KAAK,KAAK,CAAC,eAAe,CAAC,GAAG,+IAAU;QACvD,MAAM,SAAS,KAAK,KAAK,CAAC,eAAe,CAAC,GAAG,+IAAU;QAEvD,4BAA4B;QAC5B,IAAK,IAAI,IAAI,CAAC,+IAAU,EAAE,KAAK,+IAAU,EAAE,IAAK;YAC9C,IAAK,IAAI,IAAI,CAAC,+IAAU,EAAE,KAAK,+IAAU,EAAE,IAAK;gBAC9C,MAAM,KAAK,SAAS;gBACpB,MAAM,KAAK,SAAS;gBACpB,MAAM,MAAM,GAAG,GAAG,CAAC,EAAE,IAAI;gBAEzB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM;oBACzB,MAAM,QAAQ,IAAI,sIAAK,CAAC,IAAI,IAAI,IAAI;oBACpC,MAAM,QAAQ;oBACd,MAAM,UAAU;oBAChB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK;gBACvB;YACF;QACF;IAEA,mEAAmE;IACrE;IAEA,SAAS,CAAS,EAAE,CAAS,EAAE,CAAS,EAAa;QACnD,MAAM,KAAK,KAAK,KAAK,CAAC,IAAI,+IAAU;QACpC,MAAM,KAAK,KAAK,KAAK,CAAC,IAAI,+IAAU;QACpC,MAAM,MAAM,GAAG,GAAG,CAAC,EAAE,IAAI;QAEzB,MAAM,QAAQ,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC;QAC9B,IAAI,CAAC,OAAO,OAAO,8IAAS,CAAC,GAAG,EAAE,iCAAiC;QAEnE,MAAM,KAAK,IAAI,KAAK,+IAAU;QAC9B,MAAM,KAAK,IAAI,KAAK,+IAAU;QAE9B,OAAO,MAAM,QAAQ,CAAC,IAAI,GAAG;IAC/B;IAEA,SAAS,CAAS,EAAE,CAAS,EAAE,CAAS,EAAE,IAAe,EAAE;QACzD,MAAM,KAAK,KAAK,KAAK,CAAC,IAAI,+IAAU;QACpC,MAAM,KAAK,KAAK,KAAK,CAAC,IAAI,+IAAU;QACpC,MAAM,MAAM,GAAG,GAAG,CAAC,EAAE,IAAI;QAEzB,IAAI,QAAQ,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC;QAC5B,IAAI,CAAC,OAAO;YACR,+EAA+E;YAC/E;QACJ;QAEA,MAAM,KAAK,IAAI,KAAK,+IAAU;QAC9B,MAAM,KAAK,IAAI,KAAK,+IAAU;QAE9B,MAAM,QAAQ,CAAC,IAAI,GAAG,IAAI;QAC1B,MAAM,UAAU;QAEhB,8BAA8B;QAC9B,IAAI,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,GAAG;QAC3C,IAAI,OAAO,+IAAU,GAAG,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,GAAG;QACxD,IAAI,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,KAAK;QAC5C,IAAI,OAAO,+IAAU,GAAG,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,KAAK;IAC3D;IAEA,gBAAgB,EAAU,EAAE,EAAU,EAAE;QACtC,MAAM,MAAM,GAAG,GAAG,CAAC,EAAE,IAAI;QACzB,MAAM,QAAQ,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC;QAC9B,IAAI,OAAO;YACP,MAAM,OAAO,GAAG;YAChB,MAAM,UAAU;QACpB;IACF;AACF"}},
    {"offset": {"line": 301, "column": 0}, "map": {"version":3,"sources":["file:///home/micqdf/ai-tests/gemini-3-pro/src/game/player/Player.ts"],"sourcesContent":["import * as THREE from 'three';\nimport { InputManager } from '../engine/InputManager';\nimport { World } from '../world/World';\nimport { BlockType, BlockColors } from '../world/constants';\n\nexport class Player {\n  camera: THREE.Camera;\n  inputManager: InputManager;\n  world: World;\n  container: HTMLElement;\n\n  position: THREE.Vector3 = new THREE.Vector3(0, 25, 0);\n  velocity: THREE.Vector3 = new THREE.Vector3();\n  direction: THREE.Vector3 = new THREE.Vector3();\n  euler: THREE.Euler = new THREE.Euler(0, 0, 0, 'YXZ');\n\n  speed: number = 5;\n  jumpForce: number = 8; // slightly higher\n  gravity: number = 20;\n  height: number = 1.7; // slightly lower than 1.8 to avoid head stuck in ceiling\n  radius: number = 0.3;\n  onGround: boolean = false;\n\n  selectedBlock: BlockType = BlockType.STONE;\n\n  // Interaction raycasting\n  raycaster: THREE.Raycaster = new THREE.Raycaster();\n\n  constructor(camera: THREE.Camera, inputManager: InputManager, world: World, container: HTMLElement) {\n    this.camera = camera;\n    this.inputManager = inputManager;\n    this.world = world;\n    this.container = container;\n\n    // Start position\n    this.position.set(0, 25, 0);\n    this.camera.position.copy(this.position);\n    this.camera.rotation.copy(this.euler);\n\n    this.initEvents();\n  }\n\n  initEvents() {\n    document.addEventListener('mousemove', (e) => {\n      if (this.inputManager.locked) {\n        this.euler.y -= e.movementX * 0.002;\n        this.euler.x -= e.movementY * 0.002;\n        this.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.euler.x));\n        this.camera.quaternion.setFromEuler(this.euler);\n      }\n    });\n\n    document.addEventListener('mousedown', (e) => {\n      if (this.inputManager.locked) {\n        if (e.button === 0) { // Left click\n          this.removeBlock();\n        } else if (e.button === 2) { // Right click\n          this.placeBlock();\n        }\n      } else {\n        if (e.button === 0) { // Click to lock\n           this.container.requestPointerLock();\n        }\n      }\n    });\n    \n    // Block selection\n    window.addEventListener('keydown', (e) => {\n        if (e.key === '1') this.selectedBlock = BlockType.DIRT;\n        if (e.key === '2') this.selectedBlock = BlockType.GRASS;\n        if (e.key === '3') this.selectedBlock = BlockType.STONE;\n        if (e.key === '4') this.selectedBlock = BlockType.WOOD;\n        if (e.key === '5') this.selectedBlock = BlockType.LEAVES;\n        if (e.key === '6') this.selectedBlock = BlockType.WATER;\n    });\n  }\n\n  update(dt: number) {\n    // Movement\n    const speed = this.inputManager.isKeyDown('ShiftLeft') ? this.speed * 0.5 : this.speed;\n    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.camera.quaternion);\n    forward.y = 0;\n    forward.normalize();\n    \n    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(this.camera.quaternion);\n    right.y = 0;\n    right.normalize();\n\n    const moveDir = new THREE.Vector3();\n    if (this.inputManager.isKeyDown('KeyW')) moveDir.add(forward);\n    if (this.inputManager.isKeyDown('KeyS')) moveDir.sub(forward);\n    if (this.inputManager.isKeyDown('KeyD')) moveDir.add(right);\n    if (this.inputManager.isKeyDown('KeyA')) moveDir.sub(right);\n\n    if (moveDir.length() > 0) moveDir.normalize();\n\n    this.velocity.x = moveDir.x * speed;\n    this.velocity.z = moveDir.z * speed;\n\n    // Jump\n    if (this.onGround && this.inputManager.isKeyDown('Space')) {\n      this.velocity.y = this.jumpForce;\n      this.onGround = false;\n    }\n\n    // Gravity\n    this.velocity.y -= this.gravity * dt;\n\n    // Physics Update\n    this.move(dt);\n    \n    // Kill Z\n    if (this.position.y < -30) {\n        this.position.set(0, 30, 0);\n        this.velocity.set(0, 0, 0);\n    }\n\n    this.camera.position.copy(this.position);\n    // Add eye height\n    this.camera.position.y += 1.6;\n  }\n\n  move(dt: number) {\n    const steps = 8; // Sub-steps for collision accuracy\n    const dtf = dt / steps;\n    \n    for (let i = 0; i < steps; i++) {\n        this.position.x += this.velocity.x * dtf;\n        this.resolveCollision('x');\n        this.position.z += this.velocity.z * dtf;\n        this.resolveCollision('z');\n        this.position.y += this.velocity.y * dtf;\n        this.resolveCollision('y');\n    }\n  }\n\n  resolveCollision(axis: 'x' | 'y' | 'z') {\n    // Simple AABB vs Voxel collision\n    // Check bounding box of player against blocks\n    \n    const minX = Math.floor(this.position.x - this.radius);\n    const maxX = Math.floor(this.position.x + this.radius);\n    const minY = Math.floor(this.position.y);\n    const maxY = Math.floor(this.position.y + this.height);\n    const minZ = Math.floor(this.position.z - this.radius);\n    const maxZ = Math.floor(this.position.z + this.radius);\n\n    for (let x = minX; x <= maxX; x++) {\n      for (let y = minY; y <= maxY; y++) {\n        for (let z = minZ; z <= maxZ; z++) {\n          const block = this.world.getBlock(x, y, z);\n          if (block !== BlockType.AIR) {\n            // Collision detected, resolve\n            if (axis === 'y') {\n               if (this.velocity.y < 0) {\n                 // Landed\n                 this.position.y = y + 1;\n                 this.velocity.y = 0;\n                 this.onGround = true;\n               } else {\n                 // Hit head\n                 this.position.y = y - this.height - 0.001;\n                 this.velocity.y = 0;\n               }\n            } else if (axis === 'x') {\n               if (this.velocity.x > 0) {\n                 this.position.x = x - this.radius - 0.001;\n               } else {\n                 this.position.x = x + 1 + this.radius + 0.001;\n               }\n               this.velocity.x = 0;\n            } else if (axis === 'z') {\n               if (this.velocity.z > 0) {\n                 this.position.z = z - this.radius - 0.001;\n               } else {\n                 this.position.z = z + 1 + this.radius + 0.001;\n               }\n               this.velocity.z = 0;\n            }\n            return; \n          }\n        }\n      }\n    }\n    if (axis === 'y' && this.velocity.y < 0) {\n        // Check if we are actually falling (no ground below)\n        // This simple check resets onGround, but the collision loop above sets it to true if we hit something.\n        // If we didn't hit anything in the loop above while moving down, we are in air.\n        this.onGround = false;\n    }\n  }\n\n  getInteractionTarget() {\n    this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);\n    const intersects = this.raycaster.intersectObjects(this.world.scene.children, true); // true for recursive? Chunk meshes are direct children usually.\n    \n    // Filter for chunk meshes only if needed, but scene should mostly be chunks\n    if (intersects.length > 0) {\n        // We need to find the exact block.\n        // Three.js raycast gives point and face.\n        // Since we are grid aligned:\n        \n        const hit = intersects[0];\n        if (!hit.face) return null;\n\n        const p = hit.point;\n        const n = hit.face.normal;\n        \n        // Determine the block coordinate inside the voxel grid.\n        // \"The hit point is on the surface of the mesh\"\n        // Move point slightly inside the block to get the removed block\n        const removePos = p.clone().add(n.clone().multiplyScalar(-0.5));\n        const placePos = p.clone().add(n.clone().multiplyScalar(0.5));\n        \n        const removeBlockPos = {\n            x: Math.floor(removePos.x),\n            y: Math.floor(removePos.y),\n            z: Math.floor(removePos.z)\n        };\n        \n        const placeBlockPos = {\n            x: Math.floor(placePos.x),\n            y: Math.floor(placePos.y),\n            z: Math.floor(placePos.z)\n        };\n\n        return { remove: removeBlockPos, place: placeBlockPos, distance: hit.distance };\n    }\n    return null;\n  }\n\n  removeBlock() {\n    const target = this.getInteractionTarget();\n    if (target && target.distance < 6) {\n        this.world.setBlock(target.remove.x, target.remove.y, target.remove.z, BlockType.AIR);\n    }\n  }\n\n  placeBlock() {\n    const target = this.getInteractionTarget();\n    if (target && target.distance < 6) {\n        // Don't place inside player\n        // Simple AABB check\n        const px = target.place.x + 0.5;\n        const py = target.place.y + 0.5;\n        const pz = target.place.z + 0.5;\n        \n        if (Math.abs(px - this.position.x) < 0.8 && Math.abs(py - (this.position.y + this.height/2)) < 1.5 && Math.abs(pz - this.position.z) < 0.8) {\n             return; // Too close\n        }\n\n        this.world.setBlock(target.place.x, target.place.y, target.place.z, this.selectedBlock);\n    }\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AAGA;;;AAEO,MAAM;IACX,OAAqB;IACrB,aAA2B;IAC3B,MAAa;IACb,UAAuB;IAEvB,WAA0B,IAAI,0JAAa,CAAC,GAAG,IAAI,GAAG;IACtD,WAA0B,IAAI,0JAAa,GAAG;IAC9C,YAA2B,IAAI,0JAAa,GAAG;IAC/C,QAAqB,IAAI,wJAAW,CAAC,GAAG,GAAG,GAAG,OAAO;IAErD,QAAgB,EAAE;IAClB,YAAoB,EAAE;IACtB,UAAkB,GAAG;IACrB,SAAiB,IAAI;IACrB,SAAiB,IAAI;IACrB,WAAoB,MAAM;IAE1B,gBAA2B,8IAAS,CAAC,KAAK,CAAC;IAE3C,yBAAyB;IACzB,YAA6B,IAAI,4JAAe,GAAG;IAEnD,YAAY,MAAoB,EAAE,YAA0B,EAAE,KAAY,EAAE,SAAsB,CAAE;QAClG,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,SAAS,GAAG;QAEjB,iBAAiB;QACjB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,IAAI;QACzB,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ;QACvC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;QAEpC,IAAI,CAAC,UAAU;IACjB;IAEA,aAAa;QACX,SAAS,gBAAgB,CAAC,aAAa,CAAC;YACtC,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE;gBAC5B,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,SAAS,GAAG;gBAC9B,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,SAAS,GAAG;gBAC9B,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,GAAG,CAAC,CAAC,KAAK,EAAE,GAAG,GAAG,KAAK,GAAG,CAAC,KAAK,EAAE,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;gBACxE,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK;YAChD;QACF;QAEA,SAAS,gBAAgB,CAAC,aAAa,CAAC;YACtC,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE;gBAC5B,IAAI,EAAE,MAAM,KAAK,GAAG;oBAClB,IAAI,CAAC,WAAW;gBAClB,OAAO,IAAI,EAAE,MAAM,KAAK,GAAG;oBACzB,IAAI,CAAC,UAAU;gBACjB;YACF,OAAO;gBACL,IAAI,EAAE,MAAM,KAAK,GAAG;oBACjB,IAAI,CAAC,SAAS,CAAC,kBAAkB;gBACpC;YACF;QACF;QAEA,kBAAkB;QAClB,OAAO,gBAAgB,CAAC,WAAW,CAAC;YAChC,IAAI,EAAE,GAAG,KAAK,KAAK,IAAI,CAAC,aAAa,GAAG,8IAAS,CAAC,IAAI;YACtD,IAAI,EAAE,GAAG,KAAK,KAAK,IAAI,CAAC,aAAa,GAAG,8IAAS,CAAC,KAAK;YACvD,IAAI,EAAE,GAAG,KAAK,KAAK,IAAI,CAAC,aAAa,GAAG,8IAAS,CAAC,KAAK;YACvD,IAAI,EAAE,GAAG,KAAK,KAAK,IAAI,CAAC,aAAa,GAAG,8IAAS,CAAC,IAAI;YACtD,IAAI,EAAE,GAAG,KAAK,KAAK,IAAI,CAAC,aAAa,GAAG,8IAAS,CAAC,MAAM;YACxD,IAAI,EAAE,GAAG,KAAK,KAAK,IAAI,CAAC,aAAa,GAAG,8IAAS,CAAC,KAAK;QAC3D;IACF;IAEA,OAAO,EAAU,EAAE;QACjB,WAAW;QACX,MAAM,QAAQ,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,eAAe,IAAI,CAAC,KAAK,GAAG,MAAM,IAAI,CAAC,KAAK;QACtF,MAAM,UAAU,IAAI,0JAAa,CAAC,GAAG,GAAG,CAAC,GAAG,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU;QAClF,QAAQ,CAAC,GAAG;QACZ,QAAQ,SAAS;QAEjB,MAAM,QAAQ,IAAI,0JAAa,CAAC,GAAG,GAAG,GAAG,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU;QAC/E,MAAM,CAAC,GAAG;QACV,MAAM,SAAS;QAEf,MAAM,UAAU,IAAI,0JAAa;QACjC,IAAI,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,SAAS,QAAQ,GAAG,CAAC;QACrD,IAAI,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,SAAS,QAAQ,GAAG,CAAC;QACrD,IAAI,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,SAAS,QAAQ,GAAG,CAAC;QACrD,IAAI,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,SAAS,QAAQ,GAAG,CAAC;QAErD,IAAI,QAAQ,MAAM,KAAK,GAAG,QAAQ,SAAS;QAE3C,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,QAAQ,CAAC,GAAG;QAC9B,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,QAAQ,CAAC,GAAG;QAE9B,OAAO;QACP,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,UAAU;YACzD,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,SAAS;YAChC,IAAI,CAAC,QAAQ,GAAG;QAClB;QAEA,UAAU;QACV,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,IAAI,CAAC,OAAO,GAAG;QAElC,iBAAiB;QACjB,IAAI,CAAC,IAAI,CAAC;QAEV,SAAS;QACT,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,IAAI;YACvB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,IAAI;YACzB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,GAAG;QAC5B;QAEA,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ;QACvC,iBAAiB;QACjB,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,IAAI;IAC5B;IAEA,KAAK,EAAU,EAAE;QACf,MAAM,QAAQ,GAAG,mCAAmC;QACpD,MAAM,MAAM,KAAK;QAEjB,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IAAK;YAC5B,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG;YACrC,IAAI,CAAC,gBAAgB,CAAC;YACtB,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG;YACrC,IAAI,CAAC,gBAAgB,CAAC;YACtB,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG;YACrC,IAAI,CAAC,gBAAgB,CAAC;QAC1B;IACF;IAEA,iBAAiB,IAAqB,EAAE;QACtC,iCAAiC;QACjC,8CAA8C;QAE9C,MAAM,OAAO,KAAK,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM;QACrD,MAAM,OAAO,KAAK,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM;QACrD,MAAM,OAAO,KAAK,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACvC,MAAM,OAAO,KAAK,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM;QACrD,MAAM,OAAO,KAAK,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM;QACrD,MAAM,OAAO,KAAK,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM;QAErD,IAAK,IAAI,IAAI,MAAM,KAAK,MAAM,IAAK;YACjC,IAAK,IAAI,IAAI,MAAM,KAAK,MAAM,IAAK;gBACjC,IAAK,IAAI,IAAI,MAAM,KAAK,MAAM,IAAK;oBACjC,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,GAAG;oBACxC,IAAI,UAAU,8IAAS,CAAC,GAAG,EAAE;wBAC3B,8BAA8B;wBAC9B,IAAI,SAAS,KAAK;4BACf,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,GAAG;gCACvB,SAAS;gCACT,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI;gCACtB,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG;gCAClB,IAAI,CAAC,QAAQ,GAAG;4BAClB,OAAO;gCACL,WAAW;gCACX,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM,GAAG;gCACpC,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG;4BACpB;wBACH,OAAO,IAAI,SAAS,KAAK;4BACtB,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,GAAG;gCACvB,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM,GAAG;4BACtC,OAAO;gCACL,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,IAAI,IAAI,CAAC,MAAM,GAAG;4BAC1C;4BACA,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG;wBACrB,OAAO,IAAI,SAAS,KAAK;4BACtB,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,GAAG;gCACvB,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM,GAAG;4BACtC,OAAO;gCACL,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,IAAI,IAAI,CAAC,MAAM,GAAG;4BAC1C;4BACA,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG;wBACrB;wBACA;oBACF;gBACF;YACF;QACF;QACA,IAAI,SAAS,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,GAAG;YACrC,qDAAqD;YACrD,uGAAuG;YACvG,gFAAgF;YAChF,IAAI,CAAC,QAAQ,GAAG;QACpB;IACF;IAEA,uBAAuB;QACrB,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,IAAI,0JAAa,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM;QACjE,MAAM,aAAa,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ,EAAE,OAAO,gEAAgE;QAErJ,4EAA4E;QAC5E,IAAI,WAAW,MAAM,GAAG,GAAG;YACvB,mCAAmC;YACnC,yCAAyC;YACzC,6BAA6B;YAE7B,MAAM,MAAM,UAAU,CAAC,EAAE;YACzB,IAAI,CAAC,IAAI,IAAI,EAAE,OAAO;YAEtB,MAAM,IAAI,IAAI,KAAK;YACnB,MAAM,IAAI,IAAI,IAAI,CAAC,MAAM;YAEzB,wDAAwD;YACxD,gDAAgD;YAChD,gEAAgE;YAChE,MAAM,YAAY,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,GAAG,cAAc,CAAC,CAAC;YAC1D,MAAM,WAAW,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,GAAG,cAAc,CAAC;YAExD,MAAM,iBAAiB;gBACnB,GAAG,KAAK,KAAK,CAAC,UAAU,CAAC;gBACzB,GAAG,KAAK,KAAK,CAAC,UAAU,CAAC;gBACzB,GAAG,KAAK,KAAK,CAAC,UAAU,CAAC;YAC7B;YAEA,MAAM,gBAAgB;gBAClB,GAAG,KAAK,KAAK,CAAC,SAAS,CAAC;gBACxB,GAAG,KAAK,KAAK,CAAC,SAAS,CAAC;gBACxB,GAAG,KAAK,KAAK,CAAC,SAAS,CAAC;YAC5B;YAEA,OAAO;gBAAE,QAAQ;gBAAgB,OAAO;gBAAe,UAAU,IAAI,QAAQ;YAAC;QAClF;QACA,OAAO;IACT;IAEA,cAAc;QACZ,MAAM,SAAS,IAAI,CAAC,oBAAoB;QACxC,IAAI,UAAU,OAAO,QAAQ,GAAG,GAAG;YAC/B,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,MAAM,CAAC,CAAC,EAAE,OAAO,MAAM,CAAC,CAAC,EAAE,OAAO,MAAM,CAAC,CAAC,EAAE,8IAAS,CAAC,GAAG;QACxF;IACF;IAEA,aAAa;QACX,MAAM,SAAS,IAAI,CAAC,oBAAoB;QACxC,IAAI,UAAU,OAAO,QAAQ,GAAG,GAAG;YAC/B,4BAA4B;YAC5B,oBAAoB;YACpB,MAAM,KAAK,OAAO,KAAK,CAAC,CAAC,GAAG;YAC5B,MAAM,KAAK,OAAO,KAAK,CAAC,CAAC,GAAG;YAC5B,MAAM,KAAK,OAAO,KAAK,CAAC,CAAC,GAAG;YAE5B,IAAI,KAAK,GAAG,CAAC,KAAK,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,OAAO,KAAK,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,GAAC,CAAC,KAAK,OAAO,KAAK,GAAG,CAAC,KAAK,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,KAAK;gBACvI,QAAQ,YAAY;YACzB;YAEA,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,KAAK,CAAC,CAAC,EAAE,OAAO,KAAK,CAAC,CAAC,EAAE,OAAO,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,aAAa;QAC1F;IACF;AACF"}},
    {"offset": {"line": 530, "column": 0}, "map": {"version":3,"sources":["file:///home/micqdf/ai-tests/gemini-3-pro/src/game/engine/InputManager.ts"],"sourcesContent":["export class InputManager {\n  keys: { [key: string]: boolean } = {};\n  locked: boolean = false;\n\n  constructor() {\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    if (typeof window === 'undefined') return;\n\n    window.addEventListener('keydown', (e) => {\n      this.keys[e.code] = true;\n    });\n\n    window.addEventListener('keyup', (e) => {\n      this.keys[e.code] = false;\n    });\n\n    document.addEventListener('pointerlockchange', () => {\n      this.locked = !!document.pointerLockElement;\n    });\n  }\n\n  isKeyDown(code: string): boolean {\n    return !!this.keys[code];\n  }\n\n  dispose() {\n    // Cleanup if necessary\n  }\n}\n"],"names":[],"mappings":";;;;AAAO,MAAM;IACX,OAAmC,CAAC,EAAE;IACtC,SAAkB,MAAM;IAExB,aAAc;QACZ,IAAI,CAAC,iBAAiB;IACxB;IAEA,oBAAoB;QAClB,wCAAmC;;;IAarC;IAEA,UAAU,IAAY,EAAW;QAC/B,OAAO,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;IAC1B;IAEA,UAAU;IACR,uBAAuB;IACzB;AACF"}},
    {"offset": {"line": 556, "column": 0}, "map": {"version":3,"sources":["file:///home/micqdf/ai-tests/gemini-3-pro/src/game/engine/GameEngine.ts"],"sourcesContent":["import * as THREE from 'three';\nimport { World } from '../world/World';\nimport { Player } from '../player/Player';\nimport { InputManager } from './InputManager';\n\nexport class GameEngine {\n  container: HTMLElement;\n  renderer: THREE.WebGLRenderer;\n  scene: THREE.Scene;\n  camera: THREE.PerspectiveCamera;\n  inputManager: InputManager;\n  \n  world: World;\n  player: Player;\n  \n  lastTime: number = 0;\n  animationId: number = 0;\n\n  constructor(container: HTMLElement) {\n    this.container = container;\n    \n    // Renderer\n    this.renderer = new THREE.WebGLRenderer({ antialias: false });\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    this.renderer.shadowMap.enabled = true;\n    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n    container.appendChild(this.renderer.domElement);\n\n    // Scene\n    this.scene = new THREE.Scene();\n    this.scene.background = new THREE.Color(0x87CEEB); // Sky blue\n    this.scene.fog = new THREE.Fog(0x87CEEB, 20, 60);\n\n    // Camera\n    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n\n    // Lighting\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n    this.scene.add(ambientLight);\n\n    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);\n    dirLight.position.set(50, 100, 50);\n    dirLight.castShadow = true;\n    dirLight.shadow.mapSize.width = 2048;\n    dirLight.shadow.mapSize.height = 2048;\n    dirLight.shadow.camera.near = 0.1;\n    dirLight.shadow.camera.far = 200;\n    dirLight.shadow.camera.left = -50;\n    dirLight.shadow.camera.right = 50;\n    dirLight.shadow.camera.top = 50;\n    dirLight.shadow.camera.bottom = -50;\n    this.scene.add(dirLight);\n\n    // Input\n    this.inputManager = new InputManager();\n\n    // World\n    this.world = new World(this.scene);\n\n    // Player\n    this.player = new Player(this.camera, this.inputManager, this.world, this.container);\n\n    // Events\n    window.addEventListener('resize', this.onResize);\n  }\n\n  start() {\n    this.lastTime = performance.now();\n    this.animate();\n  }\n\n  animate = () => {\n    const time = performance.now();\n    const delta = (time - this.lastTime) / 1000;\n    this.lastTime = time;\n\n    this.player.update(delta);\n    this.world.update(this.player.position);\n\n    this.renderer.render(this.scene, this.camera);\n    this.animationId = requestAnimationFrame(this.animate);\n  };\n\n  onResize = () => {\n    this.camera.aspect = window.innerWidth / window.innerHeight;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n  };\n\n  dispose() {\n    cancelAnimationFrame(this.animationId);\n    window.removeEventListener('resize', this.onResize);\n    this.inputManager.dispose();\n    this.renderer.dispose();\n    if (this.container.contains(this.renderer.domElement)) {\n      this.container.removeChild(this.renderer.domElement);\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 652, "column": 0}, "map": {"version":3,"sources":["file:///home/micqdf/ai-tests/gemini-3-pro/src/game/ui/UI.tsx"],"sourcesContent":["import React, { useEffect, useState, useRef } from 'react';\nimport { GameEngine } from '../engine/GameEngine';\nimport { BlockType, BlockColors } from '../world/constants';\n\ninterface UIProps {\n  engineRef: React.MutableRefObject<GameEngine | null>;\n}\n\nexport default function UI({ engineRef }: UIProps) {\n  const [fps, setFps] = useState(0);\n  const [pos, setPos] = useState({ x: 0, y: 0, z: 0 });\n  const [selectedBlock, setSelectedBlock] = useState<BlockType>(BlockType.STONE);\n  \n  const requestRef = useRef<number>(0);\n  const lastTimeRef = useRef<number>(performance.now());\n  const framesRef = useRef<number>(0);\n\n  useEffect(() => {\n    const update = () => {\n      if (engineRef.current) {\n        // Position\n        const p = engineRef.current.player.position;\n        setPos({ x: Math.round(p.x), y: Math.round(p.y), z: Math.round(p.z) });\n\n        // Selected Block\n        setSelectedBlock(engineRef.current.player.selectedBlock);\n\n        // FPS\n        framesRef.current++;\n        const time = performance.now();\n        if (time - lastTimeRef.current >= 1000) {\n          setFps(framesRef.current);\n          framesRef.current = 0;\n          lastTimeRef.current = time;\n        }\n      }\n      requestRef.current = requestAnimationFrame(update);\n    };\n\n    requestRef.current = requestAnimationFrame(update);\n\n    return () => cancelAnimationFrame(requestRef.current);\n  }, [engineRef]);\n\n  const blockName = (type: BlockType) => BlockType[type];\n\n  return (\n    <div id=\"ui-layer\">\n      <div style={{ display: 'flex', flexDirection: 'column', gap: '5px' }}>\n        <div>FPS: {fps}</div>\n        <div>Pos: {pos.x}, {pos.y}, {pos.z}</div>\n        <div>Controls: WASD + Mouse, Space (Jump), Shift (Run)</div>\n        <div>Click to lock cursor</div>\n        <div>Keys 1-6 to select block</div>\n      </div>\n\n      <div id=\"crosshair\" />\n\n      <div style={{ display: 'flex', gap: '10px', justifyContent: 'center' }}>\n        {[BlockType.DIRT, BlockType.GRASS, BlockType.STONE, BlockType.WOOD, BlockType.LEAVES, BlockType.WATER].map((type) => (\n            <div \n                key={type}\n                style={{\n                    width: '40px',\n                    height: '40px',\n                    backgroundColor: '#' + BlockColors[type].toString(16).padStart(6, '0'),\n                    border: selectedBlock === type ? '4px solid white' : '2px solid black',\n                    display: 'flex',\n                    alignItems: 'center',\n                    justifyContent: 'center',\n                    fontSize: '10px',\n                    textShadow: 'none',\n                    color: 'white'\n                }}\n            >\n             {/* {blockName(type).substring(0, 2)} */}\n            </div>\n        ))}\n        <div style={{ marginLeft: '10px', alignSelf: 'center' }}>\n            Current: {blockName(selectedBlock)}\n        </div>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAAA;AAEA;;;;AAMe,SAAS,GAAG,EAAE,SAAS,EAAW;IAC/C,MAAM,CAAC,KAAK,OAAO,GAAG,IAAA,iNAAQ,EAAC;IAC/B,MAAM,CAAC,KAAK,OAAO,GAAG,IAAA,iNAAQ,EAAC;QAAE,GAAG;QAAG,GAAG;QAAG,GAAG;IAAE;IAClD,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,iNAAQ,EAAY,8IAAS,CAAC,KAAK;IAE7E,MAAM,aAAa,IAAA,+MAAM,EAAS;IAClC,MAAM,cAAc,IAAA,+MAAM,EAAS,YAAY,GAAG;IAClD,MAAM,YAAY,IAAA,+MAAM,EAAS;IAEjC,IAAA,kNAAS,EAAC;QACR,MAAM,SAAS;YACb,IAAI,UAAU,OAAO,EAAE;gBACrB,WAAW;gBACX,MAAM,IAAI,UAAU,OAAO,CAAC,MAAM,CAAC,QAAQ;gBAC3C,OAAO;oBAAE,GAAG,KAAK,KAAK,CAAC,EAAE,CAAC;oBAAG,GAAG,KAAK,KAAK,CAAC,EAAE,CAAC;oBAAG,GAAG,KAAK,KAAK,CAAC,EAAE,CAAC;gBAAE;gBAEpE,iBAAiB;gBACjB,iBAAiB,UAAU,OAAO,CAAC,MAAM,CAAC,aAAa;gBAEvD,MAAM;gBACN,UAAU,OAAO;gBACjB,MAAM,OAAO,YAAY,GAAG;gBAC5B,IAAI,OAAO,YAAY,OAAO,IAAI,MAAM;oBACtC,OAAO,UAAU,OAAO;oBACxB,UAAU,OAAO,GAAG;oBACpB,YAAY,OAAO,GAAG;gBACxB;YACF;YACA,WAAW,OAAO,GAAG,sBAAsB;QAC7C;QAEA,WAAW,OAAO,GAAG,sBAAsB;QAE3C,OAAO,IAAM,qBAAqB,WAAW,OAAO;IACtD,GAAG;QAAC;KAAU;IAEd,MAAM,YAAY,CAAC,OAAoB,8IAAS,CAAC,KAAK;IAEtD,qBACE,8OAAC;QAAI,IAAG;;0BACN,8OAAC;gBAAI,OAAO;oBAAE,SAAS;oBAAQ,eAAe;oBAAU,KAAK;gBAAM;;kCACjE,8OAAC;;4BAAI;4BAAM;;;;;;;kCACX,8OAAC;;4BAAI;4BAAM,IAAI,CAAC;4BAAC;4BAAG,IAAI,CAAC;4BAAC;4BAAG,IAAI,CAAC;;;;;;;kCAClC,8OAAC;kCAAI;;;;;;kCACL,8OAAC;kCAAI;;;;;;kCACL,8OAAC;kCAAI;;;;;;;;;;;;0BAGP,8OAAC;gBAAI,IAAG;;;;;;0BAER,8OAAC;gBAAI,OAAO;oBAAE,SAAS;oBAAQ,KAAK;oBAAQ,gBAAgB;gBAAS;;oBAClE;wBAAC,8IAAS,CAAC,IAAI;wBAAE,8IAAS,CAAC,KAAK;wBAAE,8IAAS,CAAC,KAAK;wBAAE,8IAAS,CAAC,IAAI;wBAAE,8IAAS,CAAC,MAAM;wBAAE,8IAAS,CAAC,KAAK;qBAAC,CAAC,GAAG,CAAC,CAAC,qBACxG,8OAAC;4BAEG,OAAO;gCACH,OAAO;gCACP,QAAQ;gCACR,iBAAiB,MAAM,gJAAW,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG;gCAClE,QAAQ,kBAAkB,OAAO,oBAAoB;gCACrD,SAAS;gCACT,YAAY;gCACZ,gBAAgB;gCAChB,UAAU;gCACV,YAAY;gCACZ,OAAO;4BACX;2BAZK;;;;;kCAiBb,8OAAC;wBAAI,OAAO;4BAAE,YAAY;4BAAQ,WAAW;wBAAS;;4BAAG;4BAC3C,UAAU;;;;;;;;;;;;;;;;;;;AAKhC"}},
    {"offset": {"line": 833, "column": 0}, "map": {"version":3,"sources":["file:///home/micqdf/ai-tests/gemini-3-pro/src/app/page.tsx"],"sourcesContent":["'use client';\n\nimport { useEffect, useRef } from 'react';\nimport { GameEngine } from '@/game/engine/GameEngine';\nimport UI from '@/game/ui/UI';\n\nexport default function Home() {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const engineRef = useRef<GameEngine | null>(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const engine = new GameEngine(containerRef.current);\n    engine.start();\n    engineRef.current = engine;\n\n    return () => {\n      engine.dispose();\n    };\n  }, []);\n\n  return (\n    <main>\n      <div id=\"game-container\" ref={containerRef} />\n      <UI engineRef={engineRef} />\n    </main>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAJA;;;;;AAMe,SAAS;IACtB,MAAM,eAAe,IAAA,+MAAM,EAAiB;IAC5C,MAAM,YAAY,IAAA,+MAAM,EAAoB;IAE5C,IAAA,kNAAS,EAAC;QACR,IAAI,CAAC,aAAa,OAAO,EAAE;QAE3B,MAAM,SAAS,IAAI,iJAAU,CAAC,aAAa,OAAO;QAClD,OAAO,KAAK;QACZ,UAAU,OAAO,GAAG;QAEpB,OAAO;YACL,OAAO,OAAO;QAChB;IACF,GAAG,EAAE;IAEL,qBACE,8OAAC;;0BACC,8OAAC;gBAAI,IAAG;gBAAiB,KAAK;;;;;;0BAC9B,8OAAC,mIAAE;gBAAC,WAAW;;;;;;;;;;;;AAGrB"}}]
}